<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Millie Burst</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #000;
            margin: 0px;
            overflow: hidden;
        }
        a {
            color: #f80;
        }
    </style>
  <script async="" data-id="five-server" data-file="/Users/ryanchampin/Development/patreon-products/instanced-3d-particle-cloud_files 4/index.html" type="application/javascript" src="./10_files/fiveserver.js"></script>
  <style>      
      /* Injected by five-server */
      @keyframes fadeOutHighlight {
        from {background-color: rgba(155,215,255,0.5);}
        to {background-color: rgba(155,215,255,0);}
      }      
      @keyframes fadeOutHighlightIMG {
        0% {filter: sepia(100%) hue-rotate(180deg) saturate(200%);}
        33% {filter: sepia(66%) hue-rotate(180deg) saturate(100%);}
        50% {filter: sepia(50%) hue-rotate(90deg) saturate(50%);}
        66% {filter: sepia(33%) hue-rotate(0deg) saturate(100%);}
        100% {filter: sepia(0%) hue-rotate(0deg) saturate(100%);}
      }
      @keyframes fiveserverInfoPopup {
        0%   {top:-40px;}
        15%  {top:4px;}
        85%  {top:4px;}
        100% {top:-40px;}
      }
      /*smaller*/
      @media (max-width: 640px) {
        #fiveserver-info-wrapper {
          max-width: 98%;
        }
        #fiveserver-info {
          border-radius: 0px;
        }      
      }

      </style></head>

	<body>

		<script src="./three.js"></script>
		<script src="./Tween.js"></script>

		<script src="./CopyShader.js"></script>
		<script src="./ConvolutionShader.js"></script>
		<script src="./ThresholdShader.js"></script>
		<script src="./VignetteShader.js"></script>

		<script src="./EffectComposer.js"></script>
		<script src="./MaskPass.js"></script>
		<script src="./RenderPass.js"></script>
		<script src="./ShaderPass.js"></script>
		<script src="./BloomPass.js"></script>


	<script id="vertexShader" type="x-shader/x-vertex">
		precision highp float;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;
		uniform sampler2D height;
		uniform float globalTime;
		uniform float effector;
		uniform float explode;

		attribute vec3 position;
		attribute vec3 normal;
		attribute vec3 offset;
		attribute vec2 uv;
		attribute vec4 orientation;
		attribute vec3 size;
		attribute vec3 color;
		attribute float id;

		varying vec2 vUv;
		varying vec3 vColor;
		varying vec3 vNormal;
		varying float vDestroy;

		vec3 rotateVectorByQuaternion( vec3 v, vec4 q ) {

			vec3 dest = vec3( 0.0 );

			float x = v.x, y  = v.y, z  = v.z;
			float qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			vec3 S = normalize( q.xyz );
			vec3 T = normalize( cross( S, v ) );
			vec3 N = normalize( cross( T, S ) );

			mat3 tsn = mat3( S, T, N );
			return tsn * v;

		}

		vec4 axisAngleToQuaternion( vec3 axis, float angle ) {

			vec4 dest = vec4( 0.0 );

			float halfAngle = angle / 2.0,
				  s = sin( halfAngle );

			dest.x = axis.x * s;
			dest.y = axis.y * s;
			dest.z = axis.z * s;
			dest.w = cos( halfAngle );

			return dest;

		}


		void main() {

			vNormal = normal;
			vec3 vPosition = position;
			vColor = color;
			vec2 myUv = normalize( offset ).xy * 0.5 + 0.5;
			myUv.x += sin(offset.x*0.005);
			myUv.y += cos(offset.z*0.0075);

			vec3 h = texture2D( height, myUv*vec2(1.0, 2.0) ).rgb;

			float localTime = id + globalTime*2.0;
			float modTime = mod( localTime, 1.0 );
			float accTime = modTime * modTime;

			float extra = 0.0;

			float dif = abs(modTime-effector);
			float effect = 0.0;

			if (dif <= 0.1) {
				effect = (0.1-dif)*(50.0);
			}
			if(size.x < 0.5) {
				effect = 0.0;
				extra = 8.0;
			}

			vec3 off = offset * (1.0+( (pow(h.r, 2.0)*(15.0+extra)) *explode ));

			off.x += (cos(10.0+off.z*0.1+h.r)*0.6)*15.0; 
			off.y += (sin(20.0+off.x*0.1+h.r)*0.4)*10.0; 
			off.z += (cos(10.0+off.y*0.1+h.r)*0.5)*15.0;

			vec4 qRotation = axisAngleToQuaternion( orientation.xyz, globalTime*40.0 + ((abs(off.x)+abs(off.z))*0.2) + explode*(1.0+h.r*5.0) );

			vPosition = rotateVectorByQuaternion( vPosition, qRotation )*(size*(1.0+h.r));
			vNormal = rotateVectorByQuaternion( normal, qRotation );

			vColor += effect*1.0;

			vUv = uv;

			vec4 mvPosition = modelViewMatrix * vec4( off+vPosition, 1.0 );

			gl_Position = projectionMatrix * mvPosition;

		}

	</script>

	<script id="fragmentShader" type="x-shader/x-fragment">
		#extension GL_OES_standard_derivatives : enable

		precision highp float;

		uniform sampler2D win;

		varying vec2 vUv;
		varying vec3 vColor;
		varying vec3 vNormal;
		varying float vDestroy;

		void main() {

			float depth = gl_FragCoord.z / gl_FragCoord.w;
			float near = 10.0;
			float far = 280.0;
			float depthcolor = 1.1 - smoothstep( near, far, depth );

			vec3 l = vec3(0.5, 0.9, 0.5);
			float d = pow( max(0.25,dot(vNormal, l)), 1.5)*1.5;

			vec4 winColor = texture2D(win, vUv);
			if (vColor.y > 0.99) {
				winColor.xyz += vColor.xyz*0.15;
			}

			gl_FragColor = vec4((vColor.xyz*winColor.xyz*d)*depthcolor,1.0);
			
		}

	</script>


		<script>

			var container;

			var camera, scene, renderer;
			var depthMaterial, depthTarget, composer, ssao, fxaa;

			var has_gl = false;

			var instanceBuffer;

			var delta;
			var time;
			var oldTime;

			var object;

			var effectThreshold;
			var materialDepth;
			var thresholdTarget;
			var depthScale = 1.0;

			init();
			animate();

			function init() {

				renderer = new THREE.WebGLRenderer({antialias: true});
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x131313 );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 10, 2000 );
				camera.position.z = 200;
				scene.add( camera );
				camera.lookAt(scene.position);

				var numOfParticles = 1000000;

				var orgGeometry = new THREE.Geometry();
				var r = 10;
				for ( var i = 0; i < numOfParticles; i ++ ) {

					var vertex1 = new THREE.Vector3();
					vertex1.x = Math.random() * 2 - 1;
					vertex1.y = Math.random() * 2 - 1;
					vertex1.z = Math.random() * 2 - 1;
					vertex1.normalize();
					vertex1.multiplyScalar( r );

					orgGeometry.vertices.push( vertex1 );

				}

				var instances = numOfParticles;

				var geometry = new THREE.InstancedBufferGeometry();

				var vertexBuffer = new THREE.InterleavedBuffer( new Float32Array( [
					-1, -1, -1, 0, -1, 0, 1, 0,
					1, -1, -1, 0, -1, 0, 1, 1,
					0, -1, 1, 0, -1, 0, 0, 1,

					-1, -1, -1, -0.5, 0.5, 0.5, 1, 0,
					0, 1, 0, -0.5, 0.5, 0.5, 1, 1,
					0, -1, 1, -0.5, 0.5, 0.5, 0, 1,

					-1, -1, -1, 0, 0.5, -1, 1, 0,
					1, -1, -1, 0, 0.5, -1, 1, 1,
					0, 1, 0, 0, 0.5, -1, 0, 1,

					1, -1, -1, 0.5, 0.5, 0.5, 1, 0,
					0, -1, 1, 0.5, 0.5, 0.5, 1, 1,
					0, 1, 0, 0.5, 0.5, 0.5, 0, 1
				] ), 8 );

				var positions = new THREE.InterleavedBufferAttribute( vertexBuffer, 3, 0 );
				geometry.addAttribute( 'position', positions );
				var normals = new THREE.InterleavedBufferAttribute( vertexBuffer, 3, 3 );
				geometry.addAttribute( 'normal', normals );		
				var uvs = new THREE.InterleavedBufferAttribute( vertexBuffer, 2, 6 );
				geometry.addAttribute( 'uv', uvs );

				var indices = new Uint16Array( [
					  0,  1,  2,      3,  5,  4,
					  6,  8,  7,      9,  11,  10
				] );

				geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );

				instanceBuffer = new THREE.InstancedInterleavedBuffer( new Float32Array( instances * 14), 14, 1 );

				var offsets = new THREE.InterleavedBufferAttribute( instanceBuffer, 3, 0 );

				for ( var i = 0, ul = offsets.count; i < ul; i++ ) {

					var x = 0;
					var r = Math.random()*(Math.PI*2);
					var d = Math.random()*40;

					if(i < 2000) {
						d += Math.random() * 150;
					}

					if(Math.random() > 0.99) {
						d += Math.random() * 100;
					}

					var y = Math.sin(r)*d;
					var z = Math.cos(r)*d;

					var x = orgGeometry.vertices[i].x;
					var y = orgGeometry.vertices[i].y;
					var z = orgGeometry.vertices[i].z;

					offsets.setXYZ( i, x, y, z );

				}

				geometry.addAttribute( 'offset', offsets ); 

				var sizes = new THREE.InterleavedBufferAttribute( instanceBuffer, 3, 3 );

				var size = 1;

				for ( var i = 0, ul = sizes.count; i < ul; i++ ) {

					var s = 0.5 + Math.random()*1;

					if(i < 10000) {
						s = 0.25+Math.random()*0.25;
					}

					sizes.setXYZ( i, s, s, s );

				}

				geometry.addAttribute( 'size', sizes ); 

				var colors = new THREE.InterleavedBufferAttribute( instanceBuffer, 3, 6 );

				var c = new THREE.Color(0xffffff);
				for ( var i = 0, ul = colors.count; i < ul; i++ ) {

					c.setHSL((orgGeometry.vertices[i].x/15*orgGeometry.vertices[i].y/15)*0.3+0.7, 1.0, 0.8-Math.random()*0.4);

					if(i < 10000) {
						c.setHSL(0.7+(i/colors.count)*0.15, 0.0, 1.0);
					}

					colors.setXYZ( i, c.r, c.g, c.b );

				}

				geometry.addAttribute( 'color', colors ); 

				var orientations = new THREE.InterleavedBufferAttribute( instanceBuffer, 4, 9 );
				var vector = new THREE.Vector4();
				for ( var i = 0, ul = orientations.count; i < ul; i++ ) {

					vector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );
					vector.normalize();

					orientations.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

				}

				geometry.addAttribute( 'orientation', orientations ); 

				var indexes = new THREE.InterleavedBufferAttribute( instanceBuffer, 1, 13 );

				for ( var i = 0, ul = indexes.count; i < ul; i++ ) {

					indexes.setX( i, Math.random() );
					
				}

				geometry.addAttribute( 'id', indexes ); 

				var material = new THREE.RawShaderMaterial( {

					uniforms: {
						win: { type: "t", value: new THREE.TextureLoader().load( "edge_tetra.jpg" ) },
						height: { type: "t", value: new THREE.TextureLoader().load( "height.jpg" ) },
						
						globalTime: { type: "f", value: 0 },
						effector: 	{ type: "f", value: 0 },
						explode: 	{ type: "f", value: 0 },
							
					},
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
					transparent: false,
					wireframe: false,

				} );

				material.uniforms.height.value.wrapS = THREE.MirroredRepeatWrapping;
				material.uniforms.height.value.wrapT = THREE.MirroredRepeatWrapping;

				object = new THREE.Mesh( geometry, material );
				object.frustumCulled = false;
				scene.add( object );

				renderer.autoClear = false;

				var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };
				thresholdTarget = new THREE.WebGLRenderTarget( window.innerWidth*depthScale, window.innerHeight*depthScale, parameters );

				var renderModel = new THREE.RenderPass( scene, camera );
				effectThreshold = new THREE.ShaderPass( THREE.ThresholdShader );
				effectThreshold.uniforms[ "tMap" ].value = thresholdTarget.texture;
				effectThreshold.uniforms[ "threshold" ].value = 0.9;
				var effectBloom = new THREE.BloomPass( 0.95 );

				var effectVignette = new THREE.ShaderPass( THREE.VignetteShader );
				effectVignette.uniforms[ "offset" ].value = 1.0;
				effectVignette.uniforms[ "darkness" ].value = 1.2;

				var effectCopy = new THREE.ShaderPass( THREE.CopyShader );
				effectCopy.renderToScreen = true;

				composer = new THREE.EffectComposer( renderer );

				composer.addPass( renderModel );
				composer.addPass( effectThreshold );
				composer.addPass( effectBloom );
				composer.addPass( effectVignette );
				composer.addPass( effectCopy );

				window.addEventListener( 'resize', onWindowResize, false );

				hit();

			}

			function hit () {
				
				var boomTween = new TWEEN.Tween(object.material.uniforms.explode)
					.to({value: 1.0}, 400)
					.delay(1000)
					.easing(TWEEN.Easing.Cubic.In)

				var boomTween2 = new TWEEN.Tween(object.material.uniforms.explode)
					.to({value: 1.7}, 4500)
					.easing(TWEEN.Easing.Cubic.Out)
					.onComplete(out);

				boomTween.chain(boomTween2);
				boomTween.start();

			}

			function out () {
				
				var outTween = new TWEEN.Tween(object.material.uniforms.explode)
					.to({value: 0.0}, 300)
					.easing(TWEEN.Easing.Cubic.In)
					.onComplete(hit);
				outTween.start();

			}

			function onWindowResize( event ) {

				var width = window.innerWidth;
				var height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();
				renderer.setSize( width, height );

				composer.setSize( width, height );

			}


			function animate() {

				requestAnimationFrame( animate );

				time = Date.now();
				delta = time - oldTime;
				oldTime = time;

				if (isNaN(delta) || delta > 1000 || delta == 0 ) {
					delta = 1000/60;
				}

				TWEEN.update();

				object.material.uniforms.globalTime.value += delta*0.00005;
				object.rotation.y += delta*0.0002;

				renderer.clear();
				renderer.render( scene, camera, thresholdTarget, true );
				composer.render();
				

			}

		</script><canvas width="4112" height="2328" style="width: 2056px; height: 1164px;"></canvas><canvas width="3794" height="2104" style="width: 1897px; height: 1052px;"></canvas>

	


</body></html>